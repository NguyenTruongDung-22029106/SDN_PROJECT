/*
  Node Gateway Adapter (Express)

  Endpoints:
    POST /api/v1/events       -> submit RecordEvent (body: JSON event)
    GET  /api/v1/trust/:id    -> evaluate QueryTrustLog

  Configuration (env vars):
    CONNECTION_PROFILE - path to connection profile JSON/YAML
    WALLET_PATH - path to wallet directory containing identity
    IDENTITY_LABEL - identity label in wallet (e.g. User1@org1.example.com)
    CHANNEL_NAME - channel name (default: sdnchannel)
    CHAINCODE_NAME - chaincode (default: trustlog)
    PORT - HTTP port (default: 3001)

  This adapter uses the official fabric-network Node SDK.
*/

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const yaml = require('js-yaml');
const path = require('path');
const fs = require('fs');
const util = require('util');
const { Gateway, Wallets } = require('fabric-network');
require('dotenv').config();

const app = express();
app.use(bodyParser.json());
app.use(cors());

const CONNECTION_PROFILE = process.env.CONNECTION_PROFILE || path.join(__dirname, '..', 'fabric-samples', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'connection-org1.json');
const WALLET_PATH = process.env.WALLET_PATH || path.join(__dirname, 'wallet');
const IDENTITY_LABEL = process.env.IDENTITY_LABEL || 'User1@org1.example.com';
const CHANNEL_NAME = process.env.CHANNEL_NAME || process.env.CHANNEL || 'sdnchannel';
const CHAINCODE_NAME = process.env.CHAINCODE_NAME || 'trustlog';
const HTTP_PORT = parseInt(process.env.PORT || '3001');

let contract = null;
let ccpGlobal = null; // keep the loaded connection profile for diagnostics

// small helper sleep
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function initGateway() {
  if (contract) return contract;

  // Load connection profile
  // IMPORTANT: Always use auto-generated connection profile to ensure both peers are included
  // (connection-org1.json from fabric-samples only has Org1 peer, but chaincode requires endorsement from both orgs)
  let ccp = null;
  let useAutoGenerated = false;
  
  if (fs.existsSync(CONNECTION_PROFILE)) {
    const ccpRaw = fs.readFileSync(CONNECTION_PROFILE, 'utf8');
    try {
      ccp = JSON.parse(ccpRaw);
      // Check if connection profile has both peers, if not, use auto-generated
      if (!ccp.peers || !ccp.peers['peer0.org2.example.com']) {
        console.warn('Connection profile only has one peer, using auto-generated profile with both peers for endorsement');
        useAutoGenerated = true;
        ccp = null;
      }
    } catch (e) {
      // try YAML
      try {
        ccp = yaml.load(ccpRaw);
        if (!ccp.peers || !ccp.peers['peer0.org2.example.com']) {
          console.warn('Connection profile only has one peer, using auto-generated profile with both peers for endorsement');
          useAutoGenerated = true;
          ccp = null;
        }
      } catch (e2) {
        throw new Error('Connection profile must be JSON or YAML for this adapter.');
      }
    }
  } else {
    useAutoGenerated = true;
  }
  
  if (useAutoGenerated || !ccp) {
    // Build a minimal connection profile dynamically from common test-network layout
    console.warn('Using auto-generated connection profile with both peers (required for endorsement policy)');

    const tlsCaPath = path.join(__dirname, '..', 'fabric-samples', 'test-network', 'organizations', 'peerOrganizations', 'org1.example.com', 'tlsca', 'tlsca.org1.example.com-cert.pem');
    if (!fs.existsSync(tlsCaPath)) {
      throw new Error('TLS CA cert not found, please provide a connection profile or set CONNECTION_PROFILE env var');
    }
    const tlsPem = fs.readFileSync(tlsCaPath, 'utf8');

    const tlsCaPathOrg2 = path.join(__dirname, '..', 'fabric-samples', 'test-network', 'organizations', 'peerOrganizations', 'org2.example.com', 'tlsca', 'tlsca.org2.example.com-cert.pem');
    const tlsPemOrg2 = fs.existsSync(tlsCaPathOrg2) ? fs.readFileSync(tlsCaPathOrg2, 'utf8') : '';

    const ordererTlsPath = path.join(__dirname, '..', 'fabric-samples', 'test-network', 'organizations', 'ordererOrganizations', 'example.com', 'orderers', 'orderer.example.com', 'tls', 'ca.crt');
    let ordererTlsPem = '';
    if (fs.existsSync(ordererTlsPath)) {
        ordererTlsPem = fs.readFileSync(ordererTlsPath, 'utf8');
    } else {
        console.warn('Orderer TLS cert not found at', ordererTlsPath);
    }

    // Minimal ccp object sufficient for fabric-network Gateway connect
    ccp = {
      name: 'test-network',
      version: '1.0.0',
      organizations: {
        Org1: {
          mspid: 'Org1MSP',
          peers: ['peer0.org1.example.com']
        },
        Org2: {
          mspid: 'Org2MSP',
          peers: ['peer0.org2.example.com']
        }
      },
      peers: {
        'peer0.org1.example.com': {
          url: process.env.PEER_ENDPOINT || 'grpcs://localhost:7051',
          tlsCACerts: { pem: tlsPem },
          grpcOptions: {
            'ssl-target-name-override': 'peer0.org1.example.com',
            'grpc.ssl_target_name_override': 'peer0.org1.example.com',
            'grpc.default_authority': 'peer0.org1.example.com'
          }
        },
        'peer0.org2.example.com': {
          url: 'grpcs://localhost:9051',
          tlsCACerts: { pem: tlsPemOrg2 },
          grpcOptions: {
            'ssl-target-name-override': 'peer0.org2.example.com',
            'grpc.ssl_target_name_override': 'peer0.org2.example.com',
            'grpc.default_authority': 'peer0.org2.example.com'
          }
        }
      },
      orderers: {
        'orderer.example.com': {
            url: 'grpcs://localhost:7050',
            tlsCACerts: { pem: ordererTlsPem },
            grpcOptions: {
                'ssl-target-name-override': 'orderer.example.com',
                'grpc.ssl_target_name_override': 'orderer.example.com',
                'grpc.default_authority': 'orderer.example.com'
            }
        }
      },
      channels: {
        [CHANNEL_NAME]: {
          peers: {
            'peer0.org1.example.com': {},
            'peer0.org2.example.com': {}
          },
          orderers: ['orderer.example.com']
        }
      }
    };
  }

  // store for later diagnostics
  ccpGlobal = ccp;

  /*
  // If an environment override for the peer endpoint is provided, ensure the
  // connection profile uses that URL but still performs TLS hostname
  // verification against the certificate common name (peer name). This
  // addresses the common Docker case where the service name (or IP) is used
  // for networking but the TLS cert is issued to e.g. "peer0.org1.example.com".
  if (process.env.PEER_ENDPOINT && ccp && ccp.peers) {
    const envUrl = process.env.PEER_ENDPOINT;
    for (const pname of Object.keys(ccp.peers)) {
      const p = ccp.peers[pname] || {};
      // override URL to the env-configured endpoint
      p.url = envUrl;
      // ensure grpcOptions exists and set ssl-target-name-override to the
      // peer identity name (the peer object key, e.g. "peer0.org1.example.com")
      p.grpcOptions = p.grpcOptions || {};
      // Use the peer object key as the ssl-target-name-override so TLS checks
      // match the certificate CN even when the network-level hostname differs.
      p.grpcOptions['ssl-target-name-override'] = pname;
      // reassign back in case original object was missing
      ccp.peers[pname] = p;
    }
    // keep the updated copy for diagnostics too
    ccpGlobal = ccp;
    console.info('Applied PEER_ENDPOINT override to connection profile peers using ssl-target-name-override');
  }
  */

  const wallet = await Wallets.newFileSystemWallet(WALLET_PATH);

  const identity = await wallet.get(IDENTITY_LABEL);
  if (!identity) {
    throw new Error(`Identity ${IDENTITY_LABEL} not found in wallet at ${WALLET_PATH}`);
  }

  const gateway = new Gateway();
  // allow override of asLocalhost via env, default to false for Docker environment
  const asLocalhost = (process.env.GATEWAY_AS_LOCALHOST === 'true');
  // Disable discovery to avoid DiscoveryService errors in some environments
  await gateway.connect(ccp, { wallet, identity: IDENTITY_LABEL, discovery: { enabled: false, asLocalhost } });

  const network = await gateway.getNetwork(CHANNEL_NAME);
  contract = network.getContract(CHAINCODE_NAME);
  console.info('Gateway connected, contract ready:', CHAINCODE_NAME);
  return contract;
}

app.post('/api/v1/events', async (req, res) => {
  try {
    const event = req.body;
    if (!event) return res.status(400).json({ error: 'Missing event body' });

    // Fix: Ensure timestamp is an integer (int64) as expected by chaincode
    if (event.timestamp && typeof event.timestamp === 'number') {
      event.timestamp = Math.floor(event.timestamp);
    }

    const c = await initGateway();
    const payload = JSON.stringify(event);
    // declare tx in outer scope so we can inspect it in the catch handler
    let tx = null;
    let result = null;
    // retry logic: tolerate transient chaincode launch/registration failures
    const maxAttempts = 3;
    const backoffMs = 1000;
    let lastErr = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        tx = c.createTransaction('RecordEvent');
        result = await tx.submit(payload);
        // success
        return res.json({ success: true, txId: tx.getTransactionId(), result: result ? result.toString() : null, attempts: attempt });
      } catch (eAttempt) {
        lastErr = eAttempt;
        console.warn(`RecordEvent attempt ${attempt} failed: ${eAttempt.message || eAttempt}`);
        // if last attempt, break and fall through to outer catch to collect diagnostics
        if (attempt < maxAttempts) {
          await sleep(backoffMs);
          continue;
        }
        // rethrow the last error to be handled by outer catch block
        throw lastErr;
      }
    }
  } catch (err) {
    console.error('RecordEvent failed:', err);
    // Diagnostic: query QueryTrustLog on each configured peer individually and save results
    try {
      // collect additional endorsement/proposal response info if present
      const endorsementDiagnostics = [];
      try {
        // Some errors from fabric-network contain an `errors` array with endorsement entries
        if (err && Array.isArray(err.errors)) {
          for (const e of err.errors) {
            if (e && Array.isArray(e.endorsements)) {
              for (const end of e.endorsements) {
                try {
                  // endorsement structures vary; try a few common shapes
                  let endorserBuf = null;
                  if (end.endorsement && end.endorsement.endorser) endorserBuf = end.endorsement.endorser;
                  else if (end.endorser) endorserBuf = end.endorser;

                  const endorser = endorserBuf ? (Buffer.isBuffer(endorserBuf) ? endorserBuf.toString('base64') : String(endorserBuf)) : null;

                  // payload may be at top-level `payload`, or under response.payload
                  let responseBuf = null;
                  if (end.payload) responseBuf = end.payload;
                  else if (end.response && end.response.payload) responseBuf = end.response.payload;

                  const responsePayload = responseBuf ? (Buffer.isBuffer(responseBuf) ? responseBuf.toString('base64') : String(responseBuf)) : null;

                  // connection/peer info when available
                  let peerName = null;
                  if (end.peer) peerName = end.peer;
                  else if (end.connection && end.connection.name) peerName = end.connection.name;

                  endorsementDiagnostics.push({ peer: peerName, endorser, responsePayload, message: end.response && end.response.message ? end.response.message : null });
                } catch (e2) {
                  // ignore serialization issues
                }
              }
            }
          }
        }
      } catch (eDump) {
        // swallow
      }

      const deviceId = (req.body && req.body.switch_id) || (req.body && req.body.device_id) || null;
      const perPeer = {};
      const peers = (ccpGlobal && ccpGlobal.peers) ? Object.keys(ccpGlobal.peers) : [];
      for (const peer of peers) {
        try {
          // build a minimal ccp focused on this peer
          const peerObj = ccpGlobal.peers[peer];
          const minimal = {
            name: ccpGlobal.name || 'minimal',
            version: ccpGlobal.version || '1.0.0',
            organizations: ccpGlobal.organizations || {},
            peers: {
              [peer]: peerObj
            },
            channels: {
              [CHANNEL_NAME]: { peers: { [peer]: {} } }
            }
          };

          const wallet = await Wallets.newFileSystemWallet(WALLET_PATH);
          const gw = new Gateway();
          // connect without discovery so we target only this peer
          // Fix: Ensure asLocalhost is false when connecting to peers inside Docker network
          await gw.connect(minimal, { wallet, identity: IDENTITY_LABEL, discovery: { enabled: false, asLocalhost: false } });
          const network = await gw.getNetwork(CHANNEL_NAME);
          const peerContract = network.getContract(CHAINCODE_NAME);
          let out = null;
          if (deviceId) {
            const payload = await peerContract.evaluateTransaction('QueryTrustLog', deviceId);
            try { out = JSON.parse(payload.toString()); } catch (e) { out = payload.toString(); }
          } else {
            out = { error: 'no device id in request body to query' };
          }
          perPeer[peer] = { success: true, data: out };
          await gw.disconnect();
        } catch (ePeer) {
          perPeer[peer] = { success: false, error: ePeer.message || String(ePeer) };
        }
      }
      const timestamp = Date.now();
  const outPath = `/tmp/blockchain_submit_diagnostics_${timestamp}.json`;
  const writeObj = { error: err.message || String(err), perPeer };
  // include a textual inspection of the original error for deeper debugging
  try { writeObj.rawError = util.inspect(err, { depth: 6 }); } catch (e) { /* ignore */ }
      if (endorsementDiagnostics.length) writeObj.endorsements = endorsementDiagnostics;
      // include transaction id when available
      try { if (tx && typeof tx.getTransactionId === 'function') writeObj.txId = tx.getTransactionId(); } catch (e) {}
      fs.writeFileSync(outPath, JSON.stringify(writeObj, null, 2), 'utf8');
      console.error('Wrote diagnostics to', outPath);
      return res.status(500).json({ error: err.message || String(err), diagnostics: outPath });
    } catch (diagErr) {
      console.error('Diagnostic collection failed:', diagErr);
      return res.status(500).json({ error: err.message || String(err), diagError: diagErr.message || String(diagErr) });
    }
  }
});

app.get('/api/v1/trust/:deviceId', async (req, res) => {
  try {
    const deviceId = req.params.deviceId;
    const c = await initGateway();
    const payload = await c.evaluateTransaction('QueryTrustLog', deviceId);
    let out = null;
    if (payload && payload.length) {
      try { out = JSON.parse(payload.toString()); } catch (e) { out = payload.toString(); }
    }
    return res.json({ success: true, trust_log: out });
  } catch (err) {
    console.error('QueryTrustLog failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

// New endpoint: Get recent attacks across all switches
app.get('/api/v1/attacks/recent', async (req, res) => {
  try {
    const timeWindow = parseInt(req.query.timeWindow || '300'); // Default 5 minutes
    const c = await initGateway();
    const payload = await c.evaluateTransaction('GetRecentAttacks', timeWindow.toString());
    let attacks = [];
    if (payload && payload.length) {
      try { attacks = JSON.parse(payload.toString()); } catch (e) { attacks = []; }
    }
    return res.json({ success: true, attacks, count: attacks.length });
  } catch (err) {
    console.error('GetRecentAttacks failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

// New endpoint: Get mitigation action recommendation
app.post('/api/v1/mitigation/action', async (req, res) => {
  try {
    const { switch_id, confidence } = req.body;
    if (!switch_id || confidence === undefined) {
      return res.status(400).json({ error: 'switch_id and confidence are required' });
    }
    const c = await initGateway();
    const payload = await c.evaluateTransaction('GetMitigationAction', switch_id, confidence.toString());
    const action = payload ? payload.toString() : 'warn_only';
    return res.json({ success: true, switch_id, confidence, action });
  } catch (err) {
    console.error('GetMitigationAction failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

// New endpoint: Check for coordinated attack
app.get('/api/v1/attacks/coordinated', async (req, res) => {
  try {
    const timeWindow = parseInt(req.query.timeWindow || '300'); // 5 minutes
    const threshold = parseInt(req.query.threshold || '3'); // 3 switches
    const c = await initGateway();
    const payload = await c.evaluateTransaction('CheckCoordinatedAttack', timeWindow.toString(), threshold.toString());
    let result = { is_coordinated: false, affected_switches: [], attack_count: 0 };
    if (payload && payload.length) {
      try {
        const parsed = JSON.parse(payload.toString());
        result = {
          is_coordinated: parsed.is_coordinated || false,
          affected_switches: parsed.affected_switches || [],
          attack_count: parsed.attack_count || 0
        };
      } catch (e) {
        console.error('Failed to parse coordinated attack result:', e);
      }
    }
    return res.json({ success: true, ...result });
  } catch (err) {
    console.error('CheckCoordinatedAttack failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

// New endpoint: Set mitigation policy
app.post('/api/v1/policy', async (req, res) => {
  try {
    const policy = req.body;
    if (!policy.policy_id) {
      return res.status(400).json({ error: 'policy_id is required' });
    }
    const c = await initGateway();
    const tx = c.createTransaction('SetMitigationPolicy');
    await tx.submit(JSON.stringify(policy));
    return res.json({ success: true, message: 'Policy set successfully', policy_id: policy.policy_id });
  } catch (err) {
    console.error('SetMitigationPolicy failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

// New endpoint: Get mitigation policy
app.get('/api/v1/policy/:policyId', async (req, res) => {
  try {
    const policyId = req.params.policyId;
    const c = await initGateway();
    const payload = await c.evaluateTransaction('GetMitigationPolicy', policyId);
    let policy = null;
    if (payload && payload.length) {
      try { policy = JSON.parse(payload.toString()); } catch (e) { policy = payload.toString(); }
    }
    return res.json({ success: true, policy });
  } catch (err) {
    console.error('GetMitigationPolicy failed:', err);
    return res.status(500).json({ error: err.message || String(err) });
  }
});

app.get('/health', (req, res) => res.json({ status: 'ok' }));

app.listen(HTTP_PORT, () => {
  console.info(`Fabric Node Gateway adapter listening on port ${HTTP_PORT}`);
  console.info(`Available endpoints:`);
  console.info(`  POST /api/v1/events                 - Record security event`);
  console.info(`  GET  /api/v1/trust/:deviceId        - Query trust log`);
  console.info(`  GET  /api/v1/attacks/recent         - Get recent attacks (timeWindow query param)`);
  console.info(`  POST /api/v1/mitigation/action      - Get mitigation recommendation`);
  console.info(`  GET  /api/v1/attacks/coordinated    - Check coordinated attack`);
  console.info(`  POST /api/v1/policy                 - Set mitigation policy`);
  console.info(`  GET  /api/v1/policy/:policyId       - Get mitigation policy`);
  console.info(`  GET  /health                        - Health check`);
});
